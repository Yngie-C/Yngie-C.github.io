---
layout: post
title: 1. 자료구조 소개
category: Data Structure with C
tag: Data-structure
---





이 카테고리에 올라올 게시물은 주로 [C로 배우는 쉬운 자료구조](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=88315041) (이지영, 한빛아카데미, 2016)를 참고하여 작성하였습니다. 저는 자료구조에 대해 전혀 무지한 상황에서 공부하는 입장이며, 저와 같은 상태에 있으신 분들께서는 포스팅을 참조하시며 같이 공부하시면 좋을 것 같습니다.



## 1) 자료구조의 이해

- 자료구조 : 자료를 효율적으로 **표현** 하고 **저장** 하고 **처리** 할 수 있도록 정리하는 것 (컴퓨터 관련 분야에서 기본적이고도 필수적인 개념)
- 자료구조의 분류 : 표현할 자료의 특성과 주된 사용 방법, 수행하는 연산의 특성, 구현에 필요한 저장 공간 용량과 실행 소요 시간 고려
  - **단순** 구조 : 정수, 실수, 문자, 문자열
  - **선형** 구조 : 순차 리스트, (단순/연결/원형) 연결 리스트, 스택, 큐, 데크
  - **비선형** 구조 : (일반/이진) 트리, (방향/무방향) 그래프
  - **파일** 구조 : 순차 파일, 색인 파일, 직접 파일



<br/>

## 2) 자료의 표현

- 컴퓨터는 1과 0 조합으로 구성된 2진수 코드 사용. 2진수 한 자리 (1 or 0) 을 표현하는 단위를 비트라고 하며, 8비트는 1바이트이다.

- 수치 자료의 표현
  - 10진수의 표현
    - **존(Zone) 형식** 표현 : 10진수 한 자리를 존 형식으로 표현하기 위해 1바이트를 한 단위로 사용. 존 형식을 표현하기 위한 한 단위의 8비트는 상위 4비트의 **존 영역** 과 하위 4비트 **수치 영역** 으로 구성. 존 영역에는 +와 -를 결정하기 위한 정보가, 수치 영역에는 10진수 한 자리를 표현하기 위한 정보가 들어간다. 여러 자리의 10진수를 표현할 때, 가장 마지막 존 영역에만 1100(+), 1101(-)가 들어가고 나머지 존 영역은 1111로 채워진다. 
    - **팩(Pack) 형식** 표현 : 존 형식에서 중복되는 존 영역(최하단 존 영역을 제외한 1111로 채워지는 부분) 때문에 생기는 메모리 낭비를 막기 위한 방법이다. 최하단의 4비트를 제외한 모든 4비트를 수치 영역으로 두고, 최하위 Sign 비트에만 1100(+) 또는 1101(-)를 채워넣는다.
    
  - 2진수의 정수 표현
  
    - n 비트 **부호 절댓값** 형식 : 최상위 1비트는 부호를 나타내는 데에 할당한다. 1(+), 0(-)를 나타낸다. 나머지 비트는 2진수 절댓값을 나타내는 데에 사용한다. 덧셈기와 뺄셈기를 따로 구현해야 한다는 단점을 가지고 있다.
  
    $$
    29 = 10011101_{(2)} \quad -29 = 00011101_{(2)}
    $$
  
    
  
    - **1의 보수** (1' Complement) 형식 : 부호 표현에 따로 비트를 할애하지 않는다. 음수를 표현할 때는 실제 1인 자리수를 0으로, 0인 자리수를 1로 표현한다. 0을 표현함에 있어서 두 표현(+0 : 00000000, -0 : 11111111)이 겹치게 되는 문제가 있다.
  
    $$
    29 = 00011101_{(2)} \quad -29 = 11100010_{(2)} \\
    +0 = 00000000_{(2)} \quad -0 = 11111111_{(2)}
    $$
  
    
  
    - **2의 보수** (1' Complement) 형식 : 부호를 표현할 때 2의 보수를 사용한다. (=1의 보수에 1을 더해준다.) 아래 7 - 4 = 3을 구하는 예시를 보자.
  
    $$
    0111_{(2)} = +7 \\
    1100_{(2)} = -4 \\
    0011_{(2)} = +3
    $$
  
    
  
  - 2진수의 실수 표현
  
    - 고정 소수점 표현 : 소수점이 항상 왼쪽에 있다고 생각하는 방식이다. 아이디어는 간단하지만 표현 범위가 좁다는 단점이 있다.
  
    $$
    0101_{(2)} = 0.0101
    $$
  
    
  
    - **부동 소수점** 표현 : 소수부와 10의 거듭제곱 형식으로 나타낸다. 고정 소수점 형식에 비해 표현 범위가 넓다는 장점이 있다.
  
    $$
    213 = 0.213 \times 10^3
    $$
  
    ![floating point](https://media.geeksforgeeks.org/wp-content/uploads/Single-Precision-IEEE-754-Floating-Point-Standard.jpg)
  
    위의 예에서 0.213은 소수부(Mantissa)로, 3은 지수부(Exponent)로 표현한다. 최상단 1비트에는 부호를 표현하기 위해 할당한다.
  
- 문자 자료의 표현
  - BCD 코드 : Binary-Coded Decimal. 상위 2비트(존 비트)와 하위 4(숫자 비트)로 구성된 6비트를 사용한다. 존 비트는 하위 숫자비트의 값이 숫자인지 문자인지를 나타내주는 값이다. 영어 소문자를 표현할 수 없다는 단점을 가지고 있다.
  
  ![BCD](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F266FD1415659E48D1E1419)
  
  - EBCDIC 코드 : Extended Binary-Coded Decimal Interchange Code. 상위 4비트(존 비트)와 하위 4비트(숫자 비트)로 구성된 8비트를 사용한다. 영어 소문자의 값을 입력할 수 있으나, 영어 이외의 다른 코드는 입력할 수 없다는 단점을 가지고 있다.
  
  ![EBCDIC](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F21416B425659E4BA0F8606)
  
  - **ASCII 코드** : American Standard Code for Information Interchange. 상위 3비트(존 비트)와 하위 4비트(숫자 비트)로 구성된 7비트를 사용한다. 존 비트와 숫자 비트를 조합하여 숫자와 영어 대소문자 뿐만 아니라 특수문자도 나타낼 수 있다. EBCDIC코드보다 표현 범위가 더 넓음에도 비트 수가 더 적어 효율적이다. 또한 남는 1비트(8-7)를 통신 과정에서 데이터의 변조, 손상을 확인할 수 있는 [패리티 비트]([https://ko.wikipedia.org/wiki/%ED%8C%A8%EB%A6%AC%ED%8B%B0_%EB%B9%84%ED%8A%B8](https://ko.wikipedia.org/wiki/패리티_비트))로 활용할 수 있다.
  
  ![ASCII1](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F243F683D5659E4F211800F)
  
  ![ASCII2](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2230FA3D5659E5BA1515AB)
  
  - **유니코드** (Unicode) : 위 표현법들은 영어 이외의 언어를 표현할 수 없다는 단점을 가지고 있다. [유니코드](https://www.unicode.org/)는 이런 문제를 해결하기 위한 표기법이다. 유니코드는 총 16비트로 구성되어 있으며 다양한 언어를 표현할 수 있다.
  
- 논리 자료의 표현 : 논리값을 표현하기 위한 자료 형식이다. 프로그램은 0을 제외하고는 모두 참으로 인식한다.

$$
00000001_{(2)} = \text{True} \quad 00000000 = \text{False} \\
11111111_{(2)} = \text{True} \quad 00000000 = \text{False} \\
01101001_{(2)} = \text{True} \quad 00000000 = \text{False} 
$$



- 포인터 자료의 표현 : **포인터** (Pointer) 자료는 메모리 주소를 표현하기 위한 자료 형식이다. 자료를 저장하고 있는 변수나 특정 위치의 메모리 주소를 저장한다. 포인터 자료를 사용하면 복잡한 자료구조 연산을 메모리에서의 주소 연산만으로 처리할 수 있다.

- 문자열 자료의 표현 : 문자열 자료란 한 글자가 아닌 여러 글자로 이루어진 문자 그룹을 하나의 자료로 취급하여 메모리에 연속적으로 저장하는 자료 형식이다. 문자열 하나는 부분 문자열을 여러 개 포함할 수 있다. 문자열 표현에는 총 3가지 방법이 있다.

  1. 부분 문자열 사이에 구분자(;) 사용
  2. 가장 긴 문자열 길이에 맞추어 고정 길이로 저장
  3. 부분 문자열을 연속 저장한 후 포인터 사용

  아래는 [Computer Data Struct String]을 각 방법으로 저장한 예시다.

![String](https://t1.daumcdn.net/cfile/tistory/992AE6495AEFF03A2E)

첫 번째 방법은 메모리 할당량이 적지만 특정 문자열을 탐색하는 데 걸리는 시간이 길다. 두 번째 방법은 특정 문자열을 빠르게 찾을 수는 있지만, 공간을 많이 낭비(검은색)하게 된다는 단점이 있다. 마지막 방법은 메모리 할당량이 가장 적고, 특정 문자열을 찾을 때에도 **메모리 연산** 을 이용하여 빠르게 찾아낼 수 있다는 장점이 있다.

| 항목                      | 메모리 이용률                                              | 부분 문자열 탐색 시간                                |
| ------------------------- | ---------------------------------------------------------- | ---------------------------------------------------- |
| 구분자를 사용하는 방법    | 문자열 길이 + 구분자 길이 → 효율적                         | 문자 비교 연산 시간 + 구분자 식별 시간 → 비효율적    |
| 고정 길이로 저장하는 방법 | 가장 긴 부분의 문자열 길이 X 부분 문자열의 개수 → 비효율적 | 문자 비교 연산 시간 → 효율적                         |
| 포인터를 사용하는 방법    | 문자열 길이 + 포인터 저장공간 → 효율적                     | 문자 비교 연산 시간 + 포인터 주소 연산 시간 → 효율적 |

<br/>

## 3) 자료의 추상화

- **추상화** (Abstraction) : 뇌가 어떤 대상 전체가 아니라 특징만을 기억한 뒤 다시 떠올리는 현상. 컴퓨터도 이와 같은 기능을 수행한다. 자료 추상화에 이용하는 기본 개념에는 자료(Data), 연산(Operation), 자료형(Data Type)이 있다.
  - **자료** : 프로그램의 처리 대상이 되는 모든 것.
  - **연산** : 어떤 일을 처리하는 과정으로 연산자를 이용하여 수행.
  - **자료형** : 처리할 자료의 집합과 자료에 대해 수행할 수 있는 연산자의 집합. 자료형을 정의할 때는 자료형에 속하는 값과 이를 처리하기 위해 사용할 수 있는 연산자를 정의한다.
    - 시스템 정의 자료형 : 프로그래밍 언어에서 정의하여 제공하는 자료형
    - 사용자 정의 자료형 : 사용자가 정의하여 쓰는 자료형, 자료형을 정의하려면 구체적으로 구현하기 전에 자료형에 대한 자료의 특성, 연산자, 연산자가 무엇을 수행하는지 등을 논리적으로 정의해놓아야 한다. 이렇게 추상화하여 정의한 자료형을 추상 자료형이라고 한다.

추상화는 이해를 위해 '무엇인지'를 논리적으로 정의하는 것이고, 구체화는 사용을 위해 '어떻게 할 지'를 실제적으로 표현하는 것이다. 

| 구분   | 자료        | 연산          |
| ------ | ----------- | ------------- |
| 추상화 | 추상 자료형 | 알고리즘 정의 |
| 구체화 | 자료형      | 프로그램 구현 |

<br/>

## 4) 알고리즘의 이해

- **알고리즘** (Algorithm) : 주어진 문제를 해결하는 방법을 추사오하하여 일련의 단계적 절차를 논리적으로 기술해 놓은 명세서.
- 알고리즘의 조건
  - 입력(Input) : 알고리즘을 수행하는 데 필요한 자료가 외부에서 입력되어야 한다.
  - 출력(Output) : 알고리즘을 수행하고 나면 결과를 하나 이상 출력해야 한다.
  - 명확성(Definiteness) : 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어는 명확하게 명시되어야 한다.
  - 유한성(Finiteness) : 알고리즘을 모두 수행하고 나면 반드시 종료되어야 한다.
  - 효과성(Effectiveness) : 알고리즘의 모든 명령어는 기본적이며 실행할 수 있어야 한다.

<br/>

## 5) 알고리즘의 표현 방법

- 자연어를 이용한 서술적 표현
- 순서도를 이용한 도식화
- 프로그래밍 언어를 이용한 구체화
- 가상코드를 이용한 추상화

<br/>

## 6) 알고리즘의 성능 분석

- 알고리즘 성능 분석 기준

  - 정확성 : 올바른 자료가 입력되었을 때 유한한 시간 내에 올바른 결과를 출력할 수 있는가
  - 명확성 : 알고리즘이 얼마나 이해하기 쉽게 작성되었는가
  - 수행량 : 일반적인 연산을 제외한 중요 연산을 분석하여 나온 수행량
  - 메모리 사용량
  - 최적성 : 시스템의 사용 환경과 중요 요구사항에 맞는 알고리즘을 작성하였는가? (가장 중요!)

- 알고리즘 성능 분석 방법
  - 공간 복잡도 : 알고리즘을 프로그램으로 실행하여 완료되는 데까지 필요한 총 저장 공간. 고정공간과 가변 공간의 합이다.
    - 고정 공간 : 프로그램 크기나 입출력 횟수와는 상관없이 고정적으로 필요한 저장공간. 프로그램 저장 공간과 변수 및 상수를 저장한다.
    - 가변 공간 : 실행 과정에서 사용하는 자료와 변수를 저장하고, 함수를 실행하는 데 관련 있는 정보를 저장하는 공간이다.
  - 시간 복잡도 : 시간 복잡도는 알고리즘을 프로그램으로 실행하여 완료하는 데까지 소요되는 시간. 프로그램의 컴파일 시간과 실행 시간을 더해 구한다. 컴파일 시간은 프로그램 특성과 큰 관련이 없지만, 실행 시간은 실행되는 컴퓨터의 성능에 따라 달라질 수 있기 때문에 명령문의 실행 빈도수를 계산하여 추정한다.
  
- 알고리즘 성능 분석 표기법

  - 빅-오 표기법 : $O(\text{f(n)})$ 과 같이 표기한다. 함수의 상한을 나타내기 위한 표기법이다. 일반적으로 최악의 경우를 따지기 때문에 가장 많이 사용된다. 먼저 실행 빈도수를 구하여 실행 시간 함수를 찾고, 이 함수값에 가장 큰 영향을 주는 n에 대한 항을 한 개 선택하여 계수는 생략하고 $O$ 의 오른쪽 괄호 안에 표시한다. 
  - 빅-오메가 표기법 : $\Omega(\text{f(n)})$ 과 같이 표기한다. 함수의 하한을 나타내기 위한 표기법이다.
  - 빅-세타 표기법 : $\theta(\text{f(n)})$ 와 같이 표기한다. 함수의 상한, 하한을 동시에 나타내기 위한 표기법이다.
  - 알고리즘에 따라 $\log n, n, n\log n, n^2, n^3, 2^n$ 등의 실행 시간 함수가 있다. 각 알고리즘에 대한 실행 빈도수는 아래의 그림을 참고하자.

  ![시간 복잡도](https://blog.chulgil.me/content/images/2019/02/Screen-Shot-2019-02-07-at-2.31.54-PM-1.png)

  

<br/>